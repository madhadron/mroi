	ImageJ only allows one region of interest (ROI) per image window, which makes working with stacks of images or images containing many objects difficult.  mroi extends this ImageJ's stack window to allow multiple ROIs in every slice of the stack.

IMAGEJ STRUCTURE
       Images and image stacks in ImageJ have the type ImagePlus.  ImageJ dates to the early versions of Java which had no support for polymorphism on numeric types, so the ImagePlus class acts as a wrapper around image classes specialized for byte, short, and float, and maintains the state of image stacks.
       The representation of an image on the screen is handled by two classes, ImageCanvas and ImageWindow.  The most straightforwards way to modify ImageJ's behavior is subclass and modify ImageCanvas.  ImageWindow has a fixed, custom layout with makes it essentially impossible to sensibly add new widgets to the image window.  If you need additional controls, create a new JFrame in a subclass of either ImageCanvas or ImageWindow.  Don't forget to destroy the JFrame in a finalize() method.
       ImageCanvas implements MouseListener, and all mouse events on the image itself, but not on the borders or controls in the image window, are passed to it.  To change the mouse behavior, override the MouseListener methods.  In most cases, if your overriding method isn't doing something special with a given method, you should pass it to the superclass's method.
       All keyboard events in ImageCanvas are sent to IJ, the singleton representation of the whole program.  The addKeyListener call is in the ImageCanvas(ImagePlus) constructor.  To handle keyboard events yourself in an ImageCanvas subclass, remove this listener with removeKeyListener(ij) after you have called the superclass constructor, and add a reference to an object implementing KeyListener with addKeyListener(yourClass).  Alternately, you can leave IJ as a KeyListener, add your own on top, but you will have to avoid ImageJ's default keybindings when you create your own commands.
       Each ImagePlus has a single ROI, accessed by its getRoi and setRoi methods.  This ROI can be null, corresponding to no region selected on the image.  The types of ROIs are subclasses of Roi.  The most useful is PolygonRoi, which also encodes line strings.

MROI DATA MODEL
       mroi uses the Geometry classes from the Java Topology Suite, a reasonably comprehensive computational geometry package, instead of ImageJ's Roi classes.  mroi.geometry.GeometryUtilities contains static methods to convert polygons and linestrings between Geometry and Roi.  Almost all methods return modified copies of data structures rather than modifying them in place.  This reflects the author's desire to write Haskell instead of Java.
       The ROIs in a given frame are represented by a list of type MZipper<Geometry>.  A zipper is a stateless way of implementing a cursor into an array.  Imagine picking up the array by the item the cursor points to, and letting the surrounding array hang down on both sides.  A zipper consists of a list of the items hanging down to the left, the current entry, and the items hanging down on the right.  It is terrible for random access, but its shortcomings are unlikely to become apparent for normal numbers of ROIs in a frame, and it is far simpler to keep a zipper consistent.
       MZipper is an interface.  The name stands for 'Maybe Zipper.'  Two classes, JZipper and NZipper, implement the interface.  JZipper ('Just Zipper') has a current entry and both tails.  NZipper ('Nothing Zipper') has only the left and right tails.  If no ROI is selected, the state of the frame's ROIs is held in an NZipper.  When an ROI is selected, it is a JZipper.
       The first slice of a stack in ImageJ is numbered as 1 instead of 0.  This doesn't fit with Java's conventions, so the MZippers for each frame are collected in a Map<Integer,MZipper<Geometry>> instead of the more sensible list.  The loss of efficiency of the data structure is more than balanced by not having to keep 1 and 0 based numbering schemes straight.
       One of the important features of mroi is undo/redo for operations on ROIs.  The undo/redo stack is again a zipper, though this time there is always a current entry (so the stack is implemented as a separate Zipper type rather than using MZipper).  Moving the cursor to the left in the zipper is undo; to the right is redo.  Moving left at the left end of a zipper leaves the zipper unchanged, as does moving right at the right end.  A command which adds, deletes, or modifies ROIs should remove everything in the right tail of the undo/redo zipper, shove the current entry onto the head of the left tail, and then put the modified version of the previous state in the current entry.
       The overall type of the data structure is Zipper<Map<Integer,MZipper<Geometry>>>, and is held in the rois field of MroiCanvas.

DRAWING ON THE CANVAS
	Painting the image on the screen is handled by the paint method of ImageCanvas.  MroiCanvas's paint method calls its superclass, then draws all the ROIs in the current slice onto the screen in red.

MOUSE INTERFACE
	MroiCanvas is its own MouseListener (and KeyListener; see the COMMANDS section).  The left mouse button behaves as it does in normal ImageJ --- the mousePressed method calls super.mousePressed --- with one difference.  In ImageJ, when you click outside the ROI, it disappears.  MroiCanvas saves the state of the ROI before calling the superclass, then restores it if the superclass made it vanish.
	The right and middle mouse buttons (interchangeably) select ROIs.  A click in an ROI selects it; a click in empty area sets unselects the current ROI without selecting another one.  MroiCanvas takes the coordinates of the mouse click, and traverses the MZipper of ROIs in the current slice.  The first one it finds, it sets to be the current ROI.
	Due to vagaries of ImageJ, this code is rather touchy, and should be left alone as much as possible.

COMMANDS
	To implement keyboard commands, MroiCanvas exposes a method (command) which will be called by the MroiCommand class.  MroiCanvas has a list of its keyboard invoked commands (keyCommands), objects implementing Command<Geometry>, which it iterates through when its command method is invoked.  Command<T> defines a boolean-valued methods, isInvoked(String).  The command method calls the exec method on any event in the list which returns true when the String it has recieved is passed to isInvoked.  To hook commands up to keys, add a macro to the macros/StartupMacros.txt file which calls 

        call("MroiCommand.run","string");

where "string" is the string which will make the desired command's isInvoked return true.

	Command<T> defines a third method besides isInvoked and exec: operation.  operation takes MZippers and returns MZippers.  All context is handled by exec.  operation encodes just the change on the ROIs in the current frame.
	Undo and Redo implement Command<T>, but don't use operation.  They operate entirely on the undo/redo zipper, so all their logic is coded straight into exec.  Most other commands will subclass one of two existing abstract implementations of Command<T>: MutatingCommand and NonmutatingCommand.  These each implement exec.  The exec of MutatingCommand creates a new layer of undo/redo containing the result of operation applied to the current slice of the previous state.  NonmutatingCommand's exec doesn't create a new undo/redo layer, and calls operation directly on the current state.
	The mouse operations described above in MOUSE INTERFACE all depend on subclasses of Command<T>, though these classes always return false from isInvoked since they are invoked by mousePressed, not through the KeyListener methods.  Select (which implements the right-click behavior described above in MOUSE INTERFACE) is a subclass of NonmutatingCommand, since it makes no change to the data in a frame.  Add (which implements the behavior of making a new ROI with the left mouse button when there wasn't one previously selected) is a subclass of MutatingCommand, as are Delete and Update.
	To implement a new tool, either make a class implementing Command (if you need access to the whole data structure), or subclass MutatingCommand or NonmutatingCommand and implement isInvoked and operation (if you are working only on the current set of ROIs).  Add an instance of the class to the list in MroiCanvas.
	In future there will be a further abstract class, MutateSingleRoiCommand, which will require subclasses to implement only isInvoked and a method which operates on a single Geometry --- the current ROI --- which will make tools such as snapping ROIs to grids very simple.
