% The Design of mroi
% Fred Ross
% Tuesday, March 9, 2010

mroi is a plugin for ImageJ that corrects that program's handling of regions of interest, and extends it with a features I found useful when segmenting time series of microscopy images.

ImageJ only allows one region of interest (ROI) per image window.  The ROI knows nothing about image stacks, and the same, single ROI, persists across all frames of a stack.  mroi changes this to allow an arbitrary number of ROI's, each fixed to a particular frame of a stack, and adds many other features on top of this.

# Compiling `mroi`

`mroi` uses a single Ant build file for everything.  To recompile `mroi`, type `ant compile`.  To run the tests as well, type `ant build` (though the tests are not that useful at the moment).  You can also run `mroi` from the command line after recompiling everything with `ant run`.

# How ImageJ represents images

ImageJ stores single images and image stacks in an object of type `ImagePlus`.  ImageJ dates from the early days of Java, when the only way to do polymorphism was unsafe casts to types known at compile time, so `ImagePlus` acts as a wrapper around image classes specialized for single images or stacks of pixel depths byte, short, and float.  The internal class which actually stores the image data is a subclass of `ImageProcessor`.  Single images are held in `ByteProcessor`, `ShortProcessor`, `FloatProcessor`, or `ColorProcessor` (for RGB images with 8 bits per channel).  Stacks are kept in a `StackProcessor`, which contains one of the single image processors inside it.

The classes `ImageCanvas` and `ImageWindow` handle displaying an image on the screen.  `ImageWindow` has a fixed, custom layout with makes it essentially impossible to sensibly add new widgets to the image window, so the most straightforwards way to modify ImageJ's behavior is to subclass and modify `ImageCanvas`.  If you need additional controls, create a new `JFrame` in your subclass, and don't forget to destroy the `JFrame` in a `finalize()` method of the subclass.

`ImageCanvas` implements a `MouseListener` which receives all mouse events on the image itself, but not on the borders or controls in the image window.  To change the mouse behavior, override the `ImageCanvas`'s `MouseListener` methods.  In most cases, if your overriding method isn't doing something special with a given method, you should pass it to the superclass's method.

`ImageCanvas` forwards all keyboard events it receives to `IJ`, the singleton representation of the whole program.  You would think that you could remove the `addKeyListener` call in the `ImageCanvas(ImagePlus)` constructor to override this, but it doesn't work.  The best way to handle keyboard events is to export a command and write a macro to call it.

Each `ImagePlus` has a single ROI, accessed by its `getRoi` and `setRoi` methods.  The ROI is either an object of some subclass of `Roi`, or `null` for no selected ROI.  In mroi, we only use the `PolygonRoi` subclass of `Roi`.

# `mroi` data model

`mroi` uses the `Geometry` classes from the Java Topology Suite, a reasonably comprehensive computational geometry package, instead of ImageJ's `Roi` classes.  `mroi.geometry.GeometryUtilities` contains static methods to convert polygons and linestrings between `Geometry` and `Roi`.  Almost all methods return modified copies of data structures rather than modifying them in place.  This reflects the author's desire to write Scheme instead of Java (and extensions to mroi can be written in Kawa Scheme).

The `Geometry` objects are wrapped in a class `RoiContainer` which encodes other necessary information about the ROI.  This is the basic unit commands work on.

The ROIs in a given frame are represented by a list of type `MZipper<Geometry>`.  A zipper is a stateless way of implementing a cursor into an array.  Imagine picking up the array by the item the cursor points to, and letting the surrounding array hang down on both sides.  A zipper consists of a list of the items hanging down to the left, the current entry, and the items hanging down on the right.  It is terrible for random access, but its shortcomings are unlikely to become apparent for normal numbers of ROIs in a frame, and it is far simpler to keep a zipper consistent.

`MZipper` is an interface.  The name stands for "Maybe Zipper".  Two classes, `JZipper` and `NZipper`, implement the interface.  `JZipper` ("Just Zipper") has a current entry and both tails.  `NZipper` ("Nothing Zipper") has only the left and right tails.  If no ROI is selected, the state of the frame's ROIs is held in an `NZipper`.  When an ROI is selected, it is a `JZipper`.

The first slice of a stack in ImageJ is numbered as 1 instead of 0.  This doesn't fit with Java's conventions, so the `MZippers` for each frame are collected in a `Map<Integer,MZipper<Geometry>>` instead of the more sensible list.  The loss of efficiency of the data structure is more than balanced by not having to keep 1 and 0 based numbering schemes straight.

One of the important features of mroi is undo/redo for operations on ROIs.  The undo/redo stack is again a zipper, though this time there is always a current entry (so the stack is implemented as a separate `Zipper` type rather than using `MZipper`).  Moving the cursor to the left in the zipper is undo; to the right is redo.  Moving left at the left end of a zipper leaves the zipper unchanged, as does moving right at the right end.  A command which adds, deletes, or modifies ROIs should remove everything in the right tail of the undo/redo zipper, shove the current entry onto the head of the left tail, and then put the new entry in the current position.

The overall type of the data structure is `Zipper<Map<Integer,MZipper<Geometry>>>`, and is held in the `rois` field of `MroiCanvas`.

# Drawing on the canvas

Painting the image on the screen is handled by the paint method of `ImageCanvas`.  `MroiCanvas`'s paint method calls its superclass, then draws all the ROIs in the current slice onto the screen in red or green, based on whether they are valid or invalid.

# Mouse interface

`MroiCanvas` is its own `MouseListener`.  The left mouse button behaves as it does in normal ImageJ - the `mousePressed` method calls `super.mousePressed` - with one difference: in ImageJ, when you click outside the ROI, it disappears.  `MroiCanvas` saves the state of the ROI before calling the superclass, then restores it if the superclass made it vanish.

The right and middle mouse buttons (interchangeably) select ROIs.  A click in an ROI selects it; a click in empty area sets unselects the current ROI without selecting another one.  `MroiCanvas` takes the coordinates of the mouse click, and traverses the `MZipper` of ROIs in the current slice.  The first one it finds, it sets to be the current ROI.

Due to vagaries of ImageJ, this code is rather touchy, and should be left alone as much as possible.

# Commands

`mroi` provides a uniform command structure.  All user interactions, whether selecting ROIs or saving sets of ROIs, are implemented as commands.  Mouse activated commands are invoked by the `MouseListener` methods of `MroiCanvas`.  Keyboard commands are a little more indirect, since ImageJ irrevocably hogs all keyboard events to its windows.

`MroiCanvas` maintains a list `keyCommands` of all commands which can be invoked by the keyboard.  It exposes a method `command` which is called by another object `MroiCommand`.  `MroiCommand` can be invoked by ImageJ macros with a call

> call("MroiCommand.run","command-name");

All commands implement the interface `Command<Geometry>`.  `"command-name"` in this call above is passed to the `isInvoked` method of every command in the `keyCommands` list in turn, until one of them returns true.  Note that the command name is case insensitive.  When a command's `isInvoked` returns true, no more of the list is traversed, and the `exec` method of the command is run.

`Command<T>` defines a third method besides `isInvoked` and `exec`: `operation`.  `operation` takes `MZippers` and returns `MZippers`.  All context, such as dealing with the undo/redo system, is handled by `exec`.  `operation` encodes just the change on the ROIs in the current frame.

Undo and Redo implement `Command<T>`, but don't use `operation`.  They operate entirely on the undo/redo zipper, so all their logic is coded straight into `exec`.  Most other commands will subclass one of two abstract subclasses of `Command<T>`, `MutatingCommand` and `NonmutatingCommand`.  These each implement `exec`, leaving the programmer to implement only `operation`.  The `exec` of `MutatingCommand` creates a new layer of undo/redo containing the result of operation applied to the current slice of the previous state.  `NonmutatingCommand`'s exec doesn't create a new undo/redo layer, and calls operation directly on the current state.

The mouse operations of `mroi` all depend on subclasses of `Command<T>`, though these classes always return false from isInvoked since they are invoked by `mousePressed` in `MroiCanvas`.  `Select`, which implements selecting and unselecting ROI's, is a subclass of `NonmutatingCommand`, since it makes no change to the data in a frame.  `Add`, which implements the behavior of making a new ROI with the left mouse button when there wasn't one previously selected, is a subclass of `MutatingCommand`, as are `Delete` and `Update`.

To implement a new tool, either make a class implementing `Command` (if you need access to the whole data structure), or subclass `MutatingCommand` or `NonmutatingCommand` and implement `isInvoked` and `operation` (if you are working only on the current set of ROIs).  Add an instance of the class to the `keyCommands` list in `MroiCanvas`.  Then put the source file for your command in `src/mroi/commands/`, and recompile `mroi`.

For commands which operate only on the currently selected ROI, `mroi` provides the classes `SingleRoiMutatingCommand` and `SingleRoiNonmutatingCommand`.  For these, you only implement `isInvoked` and a method `RoiContainer singleRoiOperation(RoiContainer c)` which operates on the selected ROI, and all other book keeping is taken care of.  For example, `ShowMean.java` in the commands source directory is a good example:

> public class ShowMean extends SingleRoiNonmutatingCommand<RoiContainer> {
> 	public boolean isInvoked(String lbl) {
>		return lbl.equalsIgnoreCase("showmean");
>	}
>	public RoiContainer singleRoiOperation(RoiContainer r) {
>		ImagePlus imp = IJ.getImage();
>		IJ.showMessage("Mean intensity of current ROI is " 
>		    + meanIntensityOfOn(r.getGeometry(), imp));
>		return r;
>	}
>}

Finally, you don't have to write your commands in Java.  `mroi`'s save, load, and export commands are all written in Kawa Scheme, which is included in the system.  If you put Scheme source files in the correct place in the source tree with suffix `.scm`, they will be compiled and built by the Ant build file like any other source code.  A command in Scheme consists of a class definition like

> (define-simple-class <mroi.commands.ScmSave> (<mroi.commands.RoiContainerCommand>)
> 	((isInvoked lbl) (<String>:equals-ignore-case lbl "scmsave"))
> 	((operation mz) #!null)
> 	((exec z frame) (save z) z))

and then definitions to make the methods work.

Marshalling Java 5 generics and Java interfaces across the boundary with Scheme is virtually impossible, so the Scheme commands all subclass `RoiContainerCommand`, which is an abstract class implementing `Command<RoiContainer>`, or `MutatingRoiContainerCommand` and `NonmutatingRoiContainerCommand` (which are exactly equivalent to `MutatingCommand<RoiContainer>` and `NonmutatingCommand<RoiContainer>`).

